---
layout: post
title: "Recursive Call - 2"
description: "하노이 탑으로 재귀 호출 이해해보기"
categories: Programming
tags: [programming, recursive, swift]
redirect_from:
   - /2018/01/03
---

> " 하노이 탑은 가장 어려운 재귀 문제이다 - 윤성우(열혈 자료구조 저자) "

# OverAll
이전 글에선 재귀의 기본적인 개념과 개발에 있어 중요한 점을 살펴 보았다.
크게 재귀 호출 순서와 관계를 생각해보아야 하고, 이를 명시적으로 판단할 수 있는 피보나치 수열을 보면서
기본적인 재귀 호출의 개념을 경험한 것을 작성해 놓았다.

하지만 모든 재귀 문제가 이렇게 명시적으로 관계와 호출 순서를 파악할 수 있지 않다.
함수의 반복 형태가 예외 없이 반복되어 함수로 이를 표현한 식. 즉, '점화식'의 형태로 나타난 것을 
프로그래밍적으로 표현하는 것으로 이를 구현할 수 있다.

대표적이고 가장 어려운 문제라고 하는 하노이 탑을 직접 구현하면서 이 기법을 공부해보았다.

#HanoiTower
예전 티벳의 예언으로서 일정 숫자의 원반을 가장 맨 끝칸으로 하루에 하나씩 옮기고 이게 모두 옮겨 졌을때
세계가 멸망하게 된다는 이야기를 옮겨놓은 문제이다.

조건은 다음과 같다.

* 기둥은 총 세개이며 맨 끝칸은 가장 오른쪽 칸이다.
* 해당 원반 위에 그보다 넓은 원반은 올라갈 수 없다.

여기서 주목해야하는 조건이 **해당 원반 위에 그보다 넓은 원반은 올라갈 수 없다.** 이다.

자기보다 작은 원반을 아래에 둘 수 없기 때문에 가장 밑에 있는 원반을 옮기기 위해선 바로 이전 (n-1)의 원반까지
정렬이 이루어져서 다른 기둥으로 옮겨져야 한다.

학생때 이 개념을 공부할땐,(그리고 아마 시험도 봤던거 같다) 처음에 이 개념을 파악하지 않고, n을 2, 3, 4 등으로 올리면서 직접 해보고 결과만을 이용해서 규칙을 추론하려 했다. 물론 못 풀었지

** 옆에서 이렇게 문제를 풀고 있는 나를 본 사람이 있다면, 그냥 눈풀려서 놀고 있는 원숭이처럼 보였겠다. 크으 code monkey 클라스 **


> 실수 노트 - 함수의 인자를 넣고 반환되는 값만을 이용해서 식을 도출하는 것이 아니라, 문제의 근본적인 원리에서 점화식을 도출하고 이를 통해 함수구조를 구성해야 했다.

# 점화식
관계, 순서 파악을 보다 용이하게 할 수 있게 낮은 수의 파라미터를 넣었고 이에 따른 따른 반환 값은 다음과 같다.

f(1) = 원반 하나가 C로 옮겨질 때 이동횟수 1
f(2) = 원반 두개가 c로 옮겨질 때 이동횟수 3
f(3) = 원반 세개의 경우 7

이렇게 직접 순서대로 진행을 하면서 하노이 탑의 이동 원리를 파악 하였다.

순서는 다음과 같다.
* 총 세개의 기둥이 있고, 이를 왼쪽부터 A,B,C라고 정의 한다.
* 기둥 한개를 이동하는 횟수는 destination 기둥이 무엇인지에 관계 없이 숫자가 같다.(A->B로 이동하나 A->C로 이동하나 그 횟수는 같다)
* 따라서 맨 마지막 원반을 C로 이동하는데에 가장 최적화 된 루트는 (n-1)개의 원반들을 B로 우선 이동한 후 C가 이동된 후에 다시 B에서 C로 이동시키는 것이다.
* 이를 식으로 표현하면 f(n-1)(A->B이동) + 1(n번째 원반이 A에서 C로 이동) + f(n-1)(B->C로 이동)

** 따라서 점화식 f(n) = 2f(n-1) + 1이 된다. **

# 구현
완성된 점화식을 기반으로 의사코드를 작성해본다.

function void hanoiTowerMove(int number, char from, char by, char to) {

if is number upper 1
     end fucntion
  
  hantoiTowerMove(number-1, From, to, by)
 // 초기 값 from은 A기둥, by는 B기동, to는 C 기둥으로 설정한다
 // A에서 B로 기둥을 움직이는 로직
 // 현재 기둥은 from(A)가 되고, 목적 기둥은 by(B)가 된다.
 
  print nDisk have moved to next pillow(To) from current pillow(From)
  
  hanoiTowerMove(number-1, by, from, to)
  // 현재 기둥이 by가 되고, 목적 기둥은 C가 된다.
  
}

코드로 직접 작성은 다음페이지에 작성하겠다 (찡긋)



